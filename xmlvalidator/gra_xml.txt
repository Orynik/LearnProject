document		::=	prolog element misc*												>XML Document
prolog			::=	xmlDecl? misc* (doctypedecl misc*)?									>Document Prolog (XML Declaration + Document Type)
xmlDecl$		::=	'<?xml' versionInfo encodingDecl? sdDecl?  S? '?>'					>XML Declaration (<?xml...?>)
versionInfo$	::= S 'version' Eq ( ( '"' VersionNum '"' ) | ( "'" VersionNum "'" ) )	>Version Info (version="1.0")
VersionNum		::= ([a-zA-Z0-9_.:] | '-')+												>Version Number (1.0)
encodingDecl$	::= S 'encoding' Eq ( ( '"' EncName '"' ) | ( "'" EncName "'" ) )		>Encoding Declaration (encoding="...")
EncName			::= [A-Za-z] ([A-Za-z0-9._] | '-')*										>Encoding Name (UTF-8, ISO-8859-1, etc)
sdDecl$			::= S 'standalone' Eq (("'" SDValue "'") | ('"' SDValue '"'))			>Standalone Declaration (standalone="...")
SDValue			::= 'yes' | 'no'														>'yes' or 'no'
misc			::=	comment | pi | S													>Comment, Processing Instruction, or Whitespace
doctypedecl$	::=	'<!DOCTYPE' S DocTypeName (S externalID)? S? ('[' extSubsetDecl? ']' S?)? '>'	>Document Type Declaration (<!DOCTYPE...>)
extSubsetDecl	::= (markupdecl | DocTypeText | S)+										>Markup Declaration or Parameter-entity Reference
DocTypeName		::= Name																>Document Type Name
DocTypeText		::= PEReference+														>Parameter-entity Reference
markupdecl		::=	elementdecl | attlistDecl | entityDecl | notationDecl | pi | comment	>Declaration for Element, Attribute List, Entity, or Notation
element			::= emptyElemTag | realElemTag											>Element (<Element>...)
realElemTag$	::= sTag content eTag { ElementName = ElementNameEnd }					>Element (<Element>...)
sTag			::=	'<' ElementName (S attribute)* S? '>'								>Element Start Tag (<Element>)
attribute$		::=	AttName Eq attQValue												>Attribute (attribute="value")
Eq!				::=	S? '=' S?															>Equal sign ('=')
eTag			::= '</' ElementNameEnd S? '>'											>Element End Tag (</Element>)
content$		::=	( element | cdSect | pi | comment | TextData | S? )*				>Element Content (Element|CData|ProcessingInstruction|Comment|Text)
TextData		::= S* ( CharNoWhite | Reference ) ( CharData | Reference )*			>Text Data
emptyElemTag$	::= '<' ElementName (S attribute)* S? '/>'								>Empty Element (<Element/>)
ElementName		::= Name																>Element Name
ElementNameEnd	::= Name																>closing element name
elementdecl$	::= '<!ELEMENT' S ElementDeclName S elementSpec							>Element Declaration (<!ELEMENT...>)
ElementDeclName$	::= NameOrPERef														>Element Name
elementSpec$	::= ( elementSpecFormatted '>' ) | ( elementSpecUnformatted	'>' )		>Element Content Specification ('EMPTY'|'ANY'|Mixed|Children|PEReference)
elementSpecFormatted$   ::= S? (elementText | elementMixed | elementChildren) S?		>Element Content Specification ('EMPTY'|'ANY'|Mixed|Children|PEReference)
elementSpecUnformatted$ ::= ([^%<>])* PEReference ([^%<>] | PEReference )*				>Element Content Specification ('EMPTY'|'ANY'|Mixed|Children|PEReference)
elementText$		::= ElementEMPTY | ElementANY | ElementPCDATA | ElementPERef		>Element Content Specification ('EMPTY'|'ANY'|(#PCData) | PEReference)
ElementEMPTY$	::= 'EMPTY'																>Element Content Specification ('EMPTY')
ElementANY$		::= 'ANY'																>Element Content Specification ('ANY'  )
ElementPCDATA$	::= '(' S? '#PCDATA' S? ')' '*'?										>Element Content Specification '(#PCDATA)'
ElementPERef$	::= PEReference															>Parameter-entity Reference (%PE;)
elementChildren$	::= (elementSeq | elementChoice) ElementRepeat?							>Children (Choice | Sequence)
ElementRepeat$	::= ('?' | '*' | '+')?														>'?' | '*' | '+'
elementChoice$	::= '(' elementChoiceI ')'												>Choice ( a | b | c )
elementChoiceI$	::= S? elementGroup ( S? '|' S? elementGroup )* S?						>Choice ( a | b | c )
elementGroup$	::= (ElementSubName | elementChoice | elementSeq) ElementRepeat?		>Name, PEReference, Choice, or Sequence
elementSeq$		::= '(' elementSeqI ')'													>Sequence ( a , b , c )
elementSeqI$	::= S? elementGroup ( S? ',' S? elementGroup )* S?						>Sequence ( a , b , c )
elementMixed$	::=	'(' elementMixedI ')*'												>Mixed (#PCDATA | Name | PEReference)
elementMixedI$	::=	S? '#PCDATA' (S? '|' S? ElementSubName)* S?							>Mixed (#PCDATA | Name | PEReference)
ElementSubName$	::= NameOrPERef															>Element Name (Name | PEReference)
attlistDecl$	::=	'<!ATTLIST' S AttlistName attlistRest								>Attribute List Declaration (<!ATTLIST...>)
AttlistName$	::= NameOrPERef															>Attribute List Name
attlistRest$	::= ( (S attlistRestFormatted)? S?'>' ) | ( S attlistRestUnformatted '>' )		>Attribute Definitions
attlistRestFormatted$   ::= attlistText															>Attribute Definitions
attlistRestUnformatted$ ::= ([^%<>])* PEReference ([^%<>] | PEReference )*						>Attribute Definitions
attlistText$	::= ( attDef (S attDef?)* )												>Attribute Definitions
attDef$			::= ( (AttDefName Snocrlf attDefRest) | AttDefPERef | (AttDefName S attDefRest) )							>Attribute Definition (Name Attribute-Type Default-Declaration)
AttDefName$		::= AttName | PEReference												>Attribute Name
AttDefPERef$	::= PEReference															>Parameter-entity Reference (%PE;)
attDefRest		::= ( attType Snocrlf? attDefault ) | AttTypePERef | ( attType S? attDefault )							>Attribute-Type
attType$		::= attTypeText | attTypeNotation | attTypeEnum							>Attribute-Type (String-Type | Tokenized-Type | Enumerated-Type)
attTypeText$	::= AttTypeCDATA | AttTypeIDREFS | AttTypeIDREF | AttTypeID | AttTypeENTITY | AttTypeENTITIES | AttTypeNMTOKENS | AttTypeNMTOKEN | AttTypePERef			>Attribute-Type (String-Type | Tokenized-Type)
AttTypeCDATA$	::= 'CDATA'																>String-Type (CDATA)
AttTypeIDREFS$	::= 'IDREFS'															>Tokenized-Type (IDREFS)
AttTypeIDREF$	::= 'IDREF'																>Tokenized-Type (IDREF)
AttTypeID$		::= 'ID'																>Tokenized-Type (ID)
AttTypeENTITY$	::= 'ENTITY'															>Tokenized-Type (ENTITY)
AttTypeENTITIES$	::= 'ENTITIES'															>Tokenized-Type (ENTITIES)
AttTypeNMTOKENS$	::= 'NMTOKENS'															>Tokenized-Type (NMTOKENS)
AttTypeNMTOKEN$	::= 'NMTOKEN'															>Tokenized-Type (NMTOKEN)
AttTypePERef$	::= PEReference															>Parameter-entity Reference (%PE;)
attTypeNotation$	::= 'NOTATION' S '(' attTypeNotI ')'								>Notation-Type ( NOTATION '(' Name | Name | ... ')' )
attTypeNotI$	::= S? AttTypeNotName (S? '|' S? AttTypeNotName)* S?					>Notation-List ( Name | Name | ...  )
AttTypeNotName$	::= NameOrPERef															>Notation-Name ( (Letter | '_' | ':') (Name-Character)* )
attTypeEnum$	::= '(' S? AttTypeEnumName (S? '|' S? AttTypeEnumName)* S? ')'			>Enumeration ( '(' Nmtoken | Nmtoken | ... ')' )
AttTypeEnumName$	::= Nmtoken | PEReference											>Nmtoken (Name-Character+)
attDefault$		::= AttREQUIRED | AttIMPLIED | ((AttFIXED S)? attDefValue) | PEReference	>Default-Declaration (#REQUIRED | #IMPLIED | #FIXED "value")
AttREQUIRED$	::= '#REQUIRED'															>Default-Declaration (#REQUIRED)
AttIMPLIED$		::= '#IMPLIED'															>Default-Declaration (#IMPLIED)
AttFIXED$		::= '#FIXED'															>Default-Declaration (#FIXED)
attDefValue$	::= attQValue															>Default Attribute Value ("value" | 'value')
Reference		::= EntityRef | CharRef													>Reference (Entity-Reference | Character-Reference)
CharRef			::= ('&#' [0-9]+ ';') | ('&#x' [0-9a-fA-F]+ ';')						>Character-Reference (&#217; or &#xEA;)
EntityRef		::= '&' Name ';'														>Entity-Reference (&Entity;)
NameOrPERef		::= Name | PEReference													>Name or Parameter-entity Reference (%PE;)
PEReference		::= '%' Name ';'														>Parameter-entity Reference (%PE;)
entityDecl		::= geDecl | peDecl														>Entity Declaration (<!ENTITY...>)
geDecl$			::= '<!ENTITY' S GEName S GEDef S? '>'									>Entity Declaration (<!ENTITY...>)
peDecl$			::= '<!ENTITY' S PEName S PEDef S? '>'									>Entity Declaration (<!ENTITY...>)
GEName			::= Name																>Entity Name
PEName			::= '%' S Name															>Parameter-entity Name
GEDef			::= EntityQValue | (externalID NDataDecl?) | PEReference				>Entity Definition (Entity-Value | External-ID NData-Declaration)
PEDef			::= EntityQValue | externalID | PEReference								>Parameter-entity Definition (Entity-Value | External-ID)
externalID$		::= (ExtIDNameSys S ExtIDTextSys) | (ExtIDNamePub S ExtIDTextPub)		>External-ID ('SYSTEM' System-Literal | 'PUBLIC' Pubid-Literal System-Literal)
ExtIDNameSys	::= 'SYSTEM'															>'SYSTEM'
ExtIDTextSys	::= SystemLiteral | PEReference											>System-Literal
ExtIDNamePub	::= 'PUBLIC'															>'PUBLIC'
ExtIDTextPub	::= ( PubidLiteral | PEReference ) S ( SystemLiteral | PEReference )	>Pubid-Literal System-Literal
NDataDecl		::= S 'NDATA' S Name													>NData-Declaration ('NDATA' Name)
notationDecl$	::= '<!NOTATION' S NotationName S NotationText S? '>'					>Notation-Declaration (<!NOTATION...>)
NotationName	::= NameOrPERef															>Notation Name
NotationText	::= externalID | PublicID												>Extermal-ID or Public-ID
PublicID		::= 'PUBLIC' S PubidLiteral												>Public-ID ('PUBLIC' Pubid-Literal)
S!				::=	(#x20 | #x09  | #x0D | #x0A)+										>Whitespace (Blank, Tab, CR, LF)
Snocrlf!		::=	(#x20 | #x09)+														>Whitespace excluding any new-line char
AttName			::=	Name																>Attribute Name
Name			::= (Letter | '_' | ':') (NameChar)*									>Name ( (Letter | '_' | ':') (Name-Character)* )
NameChar		::= Letter | Digit | '.' | '-' | '_' | ':'								>Name-Character (Letter | Digit | '.' | '-' | '_' | ':')
Nmtoken			::= NameChar+															>Nmtoken (Name-Character+)
EntityQValue	::= ('"' EntityValue1 '"') | ("'" EntityValue2 "'")						>Quoted Entity-Value
EntityValue1	::= ([^%&"] | PEReference | Reference)*									>Entity Value
EntityValue2	::= ([^%&'] | PEReference | Reference)*									>Entity Value
attQValue		::=	('"' AttValue1 '"') | ("'" AttValue2 "'")							>Quoted Attribute Value ("value" | 'value')
AttValue1		::= ([^<&"] | Reference)*												>Attribute Value
AttValue2		::= ([^<&'] | Reference)*												>Attribute Value
SystemLiteral	::= ('"' [^"]* '"') | ("'" [^']* "'")									>System Literal
PubidLiteral	::= ('"' PubidChar* '"') | ("'" (PubidCharNoQu)* "'")					>Pubid Literal
PubidChar!		::= #x20 | #x0D | #x0A | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]			>Pubid Character
PubidCharNoQu!	::= #x20 | #x0D | #x0A | [a-zA-Z0-9] | [-()+,./:=?;!*#@$_%]				>Pubid Character (no quotes)
CharData		::=	[^<&]* / ']]>'														>Character Data
CharNoWhite!	::=	[^<&#x20#x09#x0D#x0A]												>Character (may not contain Whitespaces)
comment			::=	'<!--' CommentText '-->'											>Comment (<!-- Text -->)
CommentText		::= (CharNoDash | ('-' CharNoDash))*									>Comment Text (may not contain '--')
CharNoDash!		::=	#x09 | #x0A | #x0D | [#x20-#x2C] | [#x2E-#xFF]						>Character (no dash)
pi$				::= '<?' PITarget (S PIData)? '?>'										>Processing Instruction (<?pi...?>)
PITarget		::= Name - 'xml'														>Processing Instruction Name (may not be 'xml')
PIData			::=	Char* / '?>'														>Processing Instruction Data
Char!			::=	#x09 | #x0A | #x0D | [#x20-#xFF]									>Character
cdSect$			::=	CDStart CData? CDEnd												>CData Section (<![CDATA[...]]>)
CDStart!		::=	'<![CDATA['															>'<!CDATA['
CData			::=	Char* / ']]>'														>Character Data
CDEnd!			::=	']]>'																>']]>'
Digit!			::=	[#x30-#x39]															>Digit ([0-9])
Letter!			::=	[#x41-#x5A] | [#x61-#x7A] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#xFF]	>Letter ([a-zA-Z], etc)
